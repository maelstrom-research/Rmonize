---
title: "The Data Processing Elements"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The Data Processing Elements}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  eval = FALSE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  echo = TRUE)

```


```{r, eval = TRUE, echo = FALSE}
source('datatables.R')

```

<style>
    .flex-container {
        display: flex;
        align-items: flex-start;
    }
    .image-container-big {
        flex: 70%;
        padding-right: 30px;
    }
    .image-container-even {
        flex: 50%;
        padding-right: 20px;
    }
    .text-container-small {
        flex: 30%;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
    }
</style>


# What is the Data Processing Elements ?

The Data Processing Elements (DPE) is a table that gathers all the harmonization 
rules used to create each variable defined in the DataSchema. This table is 
typically an Excel spreadsheet where each row indicates how the 
input variables are processed to generate a harmonized variable. 
Once this table is filled, it is used in the 
[harmo_process()](../reference/harmo_process.html) function along 
with the other two parameters (data_schema and dossier) to create the 
harmonized_dossier. If harmonization cannot be performed correctly due to errors 
in the DPE, the harmonized_dossier generated can be sent to the 
[show_harmo_error()](../reference/show_harmo_error.html) function, 
allowing the user to correct the DPE and restart 
the process.

## Cheat Sheet :

::: {} 
  `r DT_rule_categories` 
:::

### General structure of the DPE {#summary}

[dataschema_variable, input_dataset and input_variables](#dsc-tbl-var)

[Mlstr_harmo::status and Mlstr_harmo::status_detail](#status)

[Mlstr_harmo::rule_category and Mlstr_harmo::algorithm](#rules)

### Harmonization rules

[id_creation](#id-creation)

[direct_mapping](#direct-mapping)

[recode](#recode)

[case_when](#case-when)

[paste](#paste)

[operation](#operation)

[other](#other)

[impossible, undertermined and \__BLANK__](#impundebla)


# General structure of the DPE 

The DPE is an typically an Excel file that you open locally in your computer and
that you can fill one row after the other to generate the rules of harmonization. 
It contains at least 5 mandatory columns, plus one additional for your documentation. 
The process cannot work if one of these columns are not present.

::: {} 
  `r DT_data_proc_elem_def` 
:::

## dataschema_variable, input_dataset and input_variables {#dsc-tbl-var}

For each DataSchema variable and each input dataset, the user must 
provide which variable(s) will be transformed to generate the harmonized variable.

* The name of each input dataset must be exactly the same (case sensitive) 
in the input dataset dossier (the dossier provided as input in the function 
[harmo_process()](../reference/harmo_process.html)).

* The name(s) of the variable(s) must be exactly the same (case sensitive) in the 
dataset where the variable name is taken from. Plus, the variable(s) must exist in 
the dataset to be used in the process.

* If no variable is needed to generate the harmonized variable (for example using
the rule category **paste** or **other**), the user must provide **\___BLANK___** as a
placeholder. This ensure that the line is completed and there is no missing
argument in the function to perform.

* If more than one variable is used to generate the harmonized variable, they must
me separated by semi colon **;**

* The first rule category for each input dataset **must** be **id_creation**

::: {} 
  `r DT_data_proc_elem_expl` 
:::

> Useful tip : You can add an index for each of your harmonised variables and 
work either per dataset or per harmonized variables using filter/order in Excel.

[return to summary](#summary)

## Mlstr_harmo::rule_category and Mlstr_harmo::algorithm {#rules}

These columns are the core center of the harmonization process. The user has access
to 5 rules of harmonization to transform, process or combine input variables
to generate harmonized variables. In addition, they have the ability to generate 
their own rule using the function 'other'. If in a dataset, no variable corresponds 
to the definition of the harmonized variable, the user can put 'impossible' 
to generate NAs and if the user needs more information decide how to harmonize a
variable, they can use the placeholder 'undermined'. 

[return to summary](#summary)

## id_creation (mandatory) {#id-creation}

This rule allows the process to initiate. This is a very important step, because
the user provides the column which will be used as a reference per observation (row)

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_id_creation`
:::

::: {style="flex: 1;"}

* This step is mandatory and must be the first rule for each dataset.

* Usually, the harmonized variable is a standardized identifier generated 
from the input identifier.

* If the dataset does not have any identifier column, the user can create 
*before harmonization* an index and provide this index as the variable to use.

:::

::::

[return to summary](#summary)

## direct_mapping {#direct-mapping}

The harmonized variable is generated by replicating one input variable.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_direct_mapping`
:::

::: {style="flex: 1;"}

* One and only one variable can be replicated at a time.

:::

::::

[return to summary](#summary)

## recode {#recode}

The harmonized variable is generated by recoding values from one input variable.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_recode`
:::

::: {style="flex: 1;"}

* One and only one variable can be recoded at a time.

* The variable to be recoded must be (partially at the very least) a categorical
variable. To recode a continuous variable (to create brackets for example.),
use **case_when** instead.

* If all categories are recoded to the same categories (recode(1 = 1 ; 2 = 2)),
Prefer **direct_mapping** instead.

* Separate each value/code with an equal sign **=**

* Separate each elements with a semi-colon **;** . 

* Use **ELSE = NA** to attribute NA to all of the other values.


:::

::::

::: {}

If an equal sign already exists in the data, use **\_=** to escape them. Equally,
if a semi-colon already exists in the data, use **\_;** to escape them.

```
recode(
   "banana ; apple"  = "fruits"    _;
   "salad  ; potatoe" = "veggies"  _;
   "bread  ; pasta"   = "carbs"        )

recode(
   "1000 (='high')  _= 3  ;
   " 500 (='mid')   _= 2  ;
   " 200 (='low')   _= 1     )

```

The values can be gathered using R synthax to recode multiple numerical values.

```
recode(
   0            = "low"   ;
   c(1:10)      = "mid"   ;
   c(-7, -99)   = NA    )

```

::: 

If the recoding requires more complex codification, use **case_when** or **other** instead.

[return to summary](#summary)

## case_when {#case-when}

The harmonized variable is generated from one or more if-else conditions, using 
one or more input variables.

The harmonized variable is generated by recoding values from one input variable.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_case_when`
:::

::: {style="flex: 1;"}

* Multiple variables can be used to combine their values using case_when. Separate
each of them in **input_variables** by a semi-colon **;**

* If only one variable is used, and is (or seems) a categorical
variable, use **recode** or **direct_mapping** instead.

* Each statement ("if ... equals, greater, is not, ...") can be use in this function.
Separate the statement/code with a tilde **~**

* Separate each elements with a semi-colon **;** . 

* Use **ELSE ~ NA** to attribute NA to all of the other values.



:::

::::

::: {}


**case_when** is sentitive to the data type. Each code generated with the statement
must have the same data type, including the NA.


```
case_when(
   var_x == 1                 ~ 1  
   var_x != 0 & !is.na(var_y) ~ 0  
   ELSE                       ~ NA_real_     )

case_when(
   var_x == 1                 ~ 1L  
   var_x != 0 & !is.na(var_y) ~ 0L  
   ELSE                       ~ NA_integer_  )
   
case_when(
   var_x == 1                 ~ "1"  
   var_x != 0 & !is.na(var_y) ~ "0"  
   ELSE                       ~ NA_character_)
   
case_when(
   var_x == 1                 ~ TRUE  
   var_x != 0 & !is.na(var_y) ~ FALSE  
   ELSE                       ~ NA           ) 

```

If the statement requires more complex codification, use **other** instead.

::: 

[return to summary](#summary)

## paste {#paste}

The harmonized variable is generated by setting the same value for all observation, 
not taken from a input variable.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_paste`
:::

::: {style="flex: 1;"}

* This function does not require any variable. The user must provide 
**\___BLANK___** as a placeholder.

* Usually, the harmonized variable is a standardized identifier for the whole 
dossier when comes the time to aggregate the harmonized datasets into a 
pooled harmonized dataset.

:::

::::

[return to summary](#summary)

## operation {#operation}

The harmonized variable is generated by applying an operation to one or more 
input variables.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_operation`
:::

::: {style="flex: 1;"}

* Multiple variables can be used to combine their values using case_when. Separate
each of them in **input_variables** by a semi-colon **;**

* If the operation (or seems) is simple, prefer **case_when**, **recode** or **direct_mapping**
instead.

* The user must have the libraries present on their machine (and loaded) to function
with the call of them in the script. To specify the library calling, use 
double two-point **::**  in the formula.

::: {style="margin-left:10%;"}

```
lubridate::year(var_x)

```
::: 

* If the operation is requires more complex codification, use **other** instead.

:::

::::

[return to summary](#summary)

## other {#other}

The harmonized variable is generated from a non-standard or complex processing 
rule, not covered by other rule categories.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_other`
:::

::: {style="flex: 1;"}

* This feature is equivalent to launch a local code/function in a R script. 

:::

::::

::: {}

If assignment is needed to modify environment of the user, use 
double assignation **<<-** to place the result in the user environment. Carefully
make sure you control your environment when using the **other** function.


```
my_harmo_var <- runif(20) + ... # complex lines of code

# double assignation to modify the environment.
harmonized_dossier$DATASET$variable_F <<- my_harmo_var

```

**other** function can be used to source a code from a different script where complex
harmonization processes are written.

```
source("my_file.R")

```

:::

[return to summary](#summary)

## impossible, undertermined and \_\_BLANK\_\_ {#impundebla}

::: {}
`r DT_impundebla`
:::

These additional features allow the user to handle specific cases. 
This ensure that the line is completed and there is no missing argument in the 
function to perform.

* *\__BLANK__* : If no variable is needed to generate the harmonized variable 
(for example using the rule category **paste** or **other**)

* *impossible* : If the project of research does not collect DataSchema variable 
or cannot be used to generate DataSchema variable or is unknown.

* *undetermined* : If the user needs further investigation to harmonize, or future
information to be completed, they can use this feature without being blocked in
the process.

[return to summary](#summary)

## Mlstr_harmo::status and Mlstr_harmo::status_detail {#status}

The harmonization status is a column for documentation which refers to the status
of harmonization. It gives additional information about the completeness of the generated
variable. Another column **Mlstr_harmo::status_details** gives further information.

::: {} 
  `r DT_mlstr_status`
:::

> * Status detail 'partial' should be only employed for prospective harmonization purposes.
Prefer Mlstr_harmo::status 'complete' / Mlstr_harmo::status_details 'compatible' instead.

[return to summary](#summary)



