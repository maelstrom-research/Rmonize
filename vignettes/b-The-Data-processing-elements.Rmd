---
title: "The Data Processing Elements"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The Data Processing Elements}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  eval = FALSE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  echo = TRUE)

```


```{r, eval = TRUE, echo = FALSE}
source('datatables.R')

```

<style>
    .flex-container {
        display: flex;
        align-items: flex-start;
    }
    .image-container-big {
        flex: 70%;
        padding-right: 30px;
    }
    .image-container-even {
        flex: 50%;
        padding-right: 20px;
    }
    .text-container-small {
        flex: 30%;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
    }
</style>


# What is the Data Processing Elements ?

The Data Processing Elements (DPE) is a table that gathers all the harmonization 
rules used to create each variable defined in the DataSchema. This table is 
typically an Excel spreadsheet where each row indicates how the 
input variables are processed to generate a harmonized variable. 
Once this table is filled, it is used in the 
[harmo_process()](../reference/harmo_process.html) function along 
with the other two parameters (data_schema and dossier) to create the 
harmonized_dossier. If harmonization cannot be performed correctly due to errors 
in the DPE, the harmonized_dossier generated can be sent to the 
[show_harmo_error()](../reference/show_harmo_error.html) function, 
allowing the user to correct the DPE and restart 
the process.

# Harmonization rules overview

[**id_creation**](#id-creation) 

The harmonized variable is a standardized identifier 
generated from the input participant identifier.


[**direct_mapping**](#direct-mapping) 

The harmonized variable is generated by replicating one 
input variable.


[**recode**](#recode) 

The harmonized variable is generated by recoding values 
from one input variable.


[**case_when**](#case-when) 

The harmonized variable is generated from one or more 
if-else conditions, using one or more input variables.


[**operation**](#operation) 

The harmonized variable is generated by applying an 
operation to one or more input variables.


[**paste**](#paste) 

The harmonized variable is generated by setting the same value 
for all observations, not taken from a input variable.


[**other**](#other) 

The harmonized variable is generated from a nonstandard or 
complex processing rule, not covered by other rule categories.


[**impossible, undertermined and** **\_\_BLANK\_\_**](#impundebla) 

These additional features allow the user to handle specific cases. 


# General structure of the DPE 

The DPE is an typically an Excel file that you open locally in your computer and
that you can fill one row after the other to generate the rules of harmonization. 
It contains at least 5 mandatory columns, plus one additional for your documentation. 
The process cannot work if one of these columns are not present.

::: {} 
  `r DT_data_proc_elem_def` 
:::

[return to summary](#summary)


# Harmonization rules

## id_creation (mandatory) {#id-creation}

This rule allows the process to initiate. This is a very important step, because
the user provides the column which will be used as a reference per observation (row)

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_id_creation`
:::

::: {style="flex: 1;"}

* This step is mandatory and must be the first rule for each dataset.

* Usually, the harmonized variable is a standardized identifier generated 
from the input identifier.

* If the dataset does not have any identifier column, the user can create 
*before harmonization* an index and provide this index as the variable to use.

:::

::::

[return to summary](#summary)

## direct_mapping {#direct-mapping}

The harmonized variable is generated by replicating one input variable.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_direct_mapping`
:::

::: {style="flex: 1;"}

* One and only one variable can be replicated at a time.

:::

::::

[return to summary](#summary)

## recode {#recode}

The harmonized variable is generated by recoding values from one input variable.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_recode`
:::

::: {style="flex: 1;"}

* One and only one variable can be recoded at a time.

* The variable to be recoded must be (partially at the very least) a categorical
variable. To recode a continuous variable (to create brackets for example.),
use **case_when** instead.

* If all categories are recoded to the same categories (recode(1 = 1 ; 2 = 2)),
Prefer **direct_mapping** instead.

* Separate each value/code with an equal sign **=**

* Separate each elements with a semi-colon **;** . 

* Use **ELSE = NA** to attribute NA to all of the other values.


:::

::::

::: {}

If an equal sign already exists in the data, use **\_=** to escape them. Equally,
if a semi-colon already exists in the data, use **\_;** to escape them.

```
recode(
   "banana ; apple"  = "fruits"    _;
   "salad  ; potatoe" = "veggies"  _;
   "bread  ; pasta"   = "carbs"        )

recode(
   "1000 (='high')  _= 3  ;
   " 500 (='mid')   _= 2  ;
   " 200 (='low')   _= 1     )

```

The values can be gathered using R syntax to recode multiple numerical values.

```
recode(
   0            = "low"   ;
   c(1:10)      = "mid"   ;
   c(-7, -99)   = NA    )

```

::: 

If the recoding requires more complex codification, use **case_when** or **other** instead.

[return to summary](#summary)

## case_when {#case-when}

The harmonized variable is generated from one or more if-else conditions, using 
one or more input variables.

The harmonized variable is generated by recoding values from one input variable.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_case_when`
:::

::: {style="flex: 1;"}

* Multiple variables can be used to combine their values using case_when. Separate
each of them in **input_variables** by a semi-colon **;**

* If only one variable is used, and is (or seems) a categorical
variable, use **recode** or **direct_mapping** instead.

* Each statement ("if ... equals, greater, is not, ...") can be use in this function.
Separate the statement/code with a tilde **~**

* Separate each elements with a semi-colon **;** . 

* Use **ELSE ~ NA** to attribute NA to all of the other values.



:::

::::

::: {}


**case_when** is sensitive to the data type. Each code generated with the statement
must have the same data type, including the NA.


```
case_when(
   var_x == 1                 ~ 1  
   var_x != 0 & !is.na(var_y) ~ 0  
   ELSE                       ~ NA_real_     )

case_when(
   var_x == 1                 ~ 1L  
   var_x != 0 & !is.na(var_y) ~ 0L  
   ELSE                       ~ NA_integer_  )
   
case_when(
   var_x == 1                 ~ "1"  
   var_x != 0 & !is.na(var_y) ~ "0"  
   ELSE                       ~ NA_character_)
   
case_when(
   var_x == 1                 ~ TRUE  
   var_x != 0 & !is.na(var_y) ~ FALSE  
   ELSE                       ~ NA           ) 

```

If the statement requires more complex codification, use **other** instead.

::: 

[return to summary](#summary)

## paste {#paste}

The harmonized variable is generated by setting the same value for all observation, 
not taken from a input variable.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_paste`
:::

::: {style="flex: 1;"}

* This function does not require any variable. The user must provide 
**\___BLANK___** as a placeholder.

* Usually, the harmonized variable is a standardized identifier for the whole 
dossier when comes the time to aggregate the harmonized datasets into a 
pooled harmonized dataset.

:::

::::

[return to summary](#summary)

## operation {#operation}

The harmonized variable is generated by applying an operation to one or more 
input variables.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_operation`
:::

::: {style="flex: 1;"}

* Multiple variables can be used to combine their values using case_when. Separate
each of them in **input_variables** by a semi-colon **;**

* If the operation (or seems) is simple, prefer **case_when**, **recode** or **direct_mapping**
instead.

* The user must have the libraries present on their machine (and loaded) to function
with the call of them in the script. To specify the library calling, use 
double two-point **::**  in the formula.

::: {style="margin-left:10%;"}

```
lubridate::year(var_x)

```
::: 

* If the operation is requires more complex codification, use **other** instead.

:::

::::

[return to summary](#summary)

## other {#other}

The harmonized variable is generated from a non-standard or complex processing 
rule, not covered by other rule categories.

:::: {style="display: flex;"}

::: {style="flex: 1;"}
`r DT_other`
:::

::: {style="flex: 1;"}

* This feature is equivalent to launch a local code/function in a R script. 

:::

::::

::: {}

If assignment is needed to modify environment of the user, use 
double assignation **<<-** to place the result in the user environment. Carefully
make sure you control your environment when using the **other** function.


```
my_harmo_var <- runif(20) + ... # complex lines of code

# double assignation to modify the environment.
harmonized_dossier$DATASET$variable_F <<- my_harmo_var

```

**other** function can be used to source a code from a different script where complex
harmonization processes are written.

```
source("my_file.R")

```

:::

[return to summary](#summary)

## impossible, undertermined and \_\_BLANK\_\_ {#impundebla}

::: {}
`r DT_impundebla`
:::

These additional features allow the user to handle specific cases. 
This ensure that the line is completed and there is no missing argument in the 
function to perform.

* *\__BLANK__* : If no variable is needed to generate the harmonized variable 
(for example using the rule category **paste** or **other**)

* *impossible* : If the project of research does not collect DataSchema variable 
or cannot be used to generate DataSchema variable or is unknown.

* *undetermined* : If the user needs further investigation to harmonize, or future
information to be completed, they can use this feature without being blocked in
the process.

[return to summary](#summary)

